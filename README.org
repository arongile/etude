#+TITLE:   ETUDE EMACS
#+AUTHOR:  Chris Zheng
#+EMAIL:   z@caudate.me
#+STARTUP: showall

* Introduction

This is the [[http://github.com/zcaudate/etude][Etude]] project, an /*emacs micro-framework*/ (aka
/use-package + two files/) with the emphasis of being highly
customisable and beginner hacker friendly. It has custom keybindings
built for the [[https://www.dvorak-keyboard.com/][Dvorak Keyboard]] layout. Although equally customisable
for the normal keyboard, the project probably is not that useful due
to the fact that most of the ecosystems are based around *hjkl*
governing movement with (refer to [[https://www.vim.org/][Vim]], [[https://github.com/emacs-evil/evil][Evil Mode]], etc.) which is not
that fun to use on a Dvorak Layout.

** Aims
To provide better usability for terminal emacs on the dvorak keyboard,
across tmux sessions over the network as well as having standard
behaviours for different operating systems.

** Dependencies

The framework is built around a very small core set of libraries:

- [[https://github.com/jwiegley/use-package][use-package]]
- [[https://github.com/abo-abo/swiper][ivy, counsel and swiper]]
- [[https://github.com/abo-abo/hydra][hydra]]
- [[https://github.com/magnars/dash.el][dash]], [[https://github.com/Wilfred/ht.el][ht]], [[https://github.com/magnars/s.el][s]] and [[https://github.com/rejeep/f.el][f]] (clojurey utils)

** Principles

The customisations follow these following principles:

- *Simplicity*: Emacs has become known for its infinite
  customisability. This causes problems because there are too many
  options and too many different teams customising. IDEs such as
  ~Eclipse~ and ~Visual Code~ are big and bulky - but they have also
  gotten very fundamental things right. The primary thing all IDEs
  have is consistent way to Run and Debug programs. Yes, it's possible
  to compile your code, surf the net, organise your holiday and
  message your friends without leaving Emacs but having to run Lisp
  code via ~C-c C-k~ and then compiling C with some other key binding
  should be a concern. Etude solves this by enforcing a global
  keybindings system based on clojure's multimethod approach to
  retro-fit an IDE-like interface for any major modes.
- *Redunduncy*: Allowing multiple ways of performing a very common
  task. For example, ~M-x~, which brings up the command prompt has an
  analogue of ~C-p~ in Sublime Text. When in the terminal the ~Meta~
  key stops working. Sometimes people bind ~C-p~ as their prefix key
  on ~tmux~. Therefore having multiple ways of accessing a very
  commonly used function helps a lot and increases usability.
- *Portability:* In this case, portability refers to the user. This is
  primarily motivated by having to constantly switch between ~<C>~,
  ~<S>~, and ~<M>~ between operating systems. In this case, certain
  commands like the /Save/ operation will be bound to ~C-s~, ~M-s~ and
  ~S-s~ for consistency's sake (as well as to perform the same action
  with minimal readjustment of muscle memory when a modifier key
  become unusable).
- *Modern*: Repurpose unused Emacs global keys for the modern
  keyboard. For example, ~C-f~ and ~C-b~ are keys for forward and back
  and using a combination of modifier keys, allow for for incremental
  movements as well as movement and selection. Generally using arrow
  keys and the mouse /(shock horror)/ suffice and so keys bound to
  ~<C>~ that govern movement/selection can be repurposed for something
  else. For marking and rectangles, it's just much faster in general
  to select with the mouse.
- *Visual* Have a overaching way to customise mode
- *Flexibility* A looser coupling between function implementation so
  that bindings and modes can be swapped out


** Library Core

There are 2 file associated purely with the framework:

- [[https://github.com/zcaudate/etude/blob/master/etude/etude-boot.el][etude-boot.el]] (to initialise ~use-package~)
- [[https://github.com/zcaudate/etude/blob/master/etude/etude-lang.el][etude-lang.el]] (defining key binding macros)

The core libraries, loaded via [[https://github.com/zcaudate/etude/blob/master/etude/etude-core.el][etude-core.el]] are organised into a
couple of categories:

- [[https://github.com/zcaudate/etude/blob/master/etude/core/etude-core-base.el][base]] (various sane defaults)
- [[https://github.com/zcaudate/etude/blob/master/etude/core/etude-core-management.el][management]] (recentf, smex, ivy, projectile, wgrep, treemacs)
- [[https://github.com/zcaudate/etude/blob/master/etude/core/etude-core-code.el][code]] (magit, company, eglot)
- [[https://github.com/zcaudate/etude/blob/master/etude/core/etude-core-os.el][os]] (vterm, eshell, cut/paste)
- [[https://github.com/zcaudate/etude/blob/master/etude/core/etude-core-style.el][style]] (nord)

** Library Modules

Etude also provides a very basic module system. The module libraries
are simply loaded via init.el and provide supplemental customisations
to the core. 

They can be optional. Some current ones that I'm working with are:

- [[https://github.com/zcaudate/etude/blob/master/etude/module/etude-module-lisp.el][lisp]] (elisp, clojure)
- [[https://github.com/zcaudate/etude/blob/master/etude/module/etude-module-org.el][org]]  (previews)
- [[https://github.com/zcaudate/etude/blob/master/etude/module/etude-module-text.el][text]] (yaml, markdown)

As can be seen by the listing, it's very basic. Where is comes
together is in the setup of the [[https://github.com/zcaudate/etude/blob/master/etude/core/etude-core-workflow.el][workflow]] file where the majority of it
all comes together.

** Workflow

The workflow file define bindings as well as menu layouts. These work
on a number of principles. Programmer Intent in emacs can be thought
of being Movements, Actions and Tasks. In this context both are fundamentally the
same except differ in the regularity that the are performed (Tasks are
actions that are performed less than onc). So To be So
an action like Move Forward might be used 50 times a minute, an action
like Check Git Repository might be used






** Background

Previous to customising this package, I had mainly been switching
between [[https://www.spacemacs.org/][Spacemacs]] and [[https://github.com/overtone/emacs-live][Emacs Live]]. I had been using emacs primarily for
coding in clojure and for a while it was fine until for reasons
unknown to me, the installation started getting slower and
slower. There were issues with upgrades to [[https://github.com/clojure-emacs/cider/][CIDER]] not being promptly
fixed in these installations and as beautiful and fully featured as
they were, all I really needed was something to connect to a clojure
repl.

It was around the time that I became aware of [[https://github.com/jwiegley/use-package][use-package]] that I
decided to hack together my own emacs customisation. It was
suprisingly easy to download libraries but I found it extremely
difficult to customise as it seemed like there was always about 20
different ways of doing the same thing and the eco-system looked quite
different to when I first started with Emacs Live in terms of the
libraries. When I started, search and narrowing was through [[https://github.com/emacs-jp/anything][anything]],
then using Spacemacs, it was [[https://github.com/emacs-helm/helm][Helm]].

I had heard of [[https://github.com/abo-abo/swiper][Ivy]] before but it seemed like just another Ido-like
library. I didn't really understand why there were so many libraries
that kind of performed the same tasks until I read the article - [[https://sam217pa.github.io/2016/09/13/from-helm-to-ivy/][From
helm, to ivy]]. And then I decided to go with the more minimalistic
approach.

As I had the extremely basic requirement of

- Start Clojure repl
- Connect to repl
- Project and buffer navigation
- Nice theme
    
I decided that those tools, along with CIDER were way more than enough
for what I was after.

Those libraries combined gave me what I thought were enough functions
to build out a menu system

with most of the bindings changed to what the author has deemed 'sane'
defaults. In doing so, there is a microframework used for defining
bindings and menus that is used to setup the workflow.

The main setup is



* Installation 

** Prerequisites

Libraries:

- [[https://github.com/BurntSushi/ripgrep][ripgrep]] - search and replace (counsel)
- [[https://github.com][fd]] - find locator (counsel)
- [[https://github.com/junegunn/fzf][fzf]] - fuzzy search (counsel)
- [[https://www.gnu.org/software/ispell/][ispell]] - spell checker (native)

** OSX

For installation on OSX, install all the tools using brew

#+BEGIN_SRC bash :os osx
brew install bat fd tree fzf ripgrep ispell
#+END_SRC

** Ubuntu

For installation

#+BEGIN_SRC shell :os ubuntu
apt install bat fd tree fzf ripgrep ispell
#+END_SRC

It's now possible to

#+BEGIN_SRC js
var a = 4
var b = 3

return a + b
#+END_SRC

#+RESULTS:
: 7


-------------
| B | A | C |
|---|---|---|
| 2 | 1 | 3 |
| b | a | c |

#+BEGIN_SRC md.graph

                 _______            
  .-------.     /      /   .-----.  
  | Write +-+->/ Edit ++->| Share |   
  '-------' ^ /______/ |   '-----'  
            |          |            
             '--------'             

#+END_SRC



#+BEGIN_SRC md.graph
  A         B         C   
  *-------->o<------->o   
  ^        / ^        |   
  |       v   \       v   
  o----->o---->o<---->*   
  D      E     F      G   
#+END_SRC


this is something pretty crazy
